#!/usr/bin/env python3

# Copyright (C) 2017-2020 The btclib developers
#
# This file is part of btclib. It is subject to the license terms in the
# LICENSE file found in the top-level directory of this distribution.
#
# No part of btclib including this file, may be copied, modified, propagated,
# or distributed except according to the terms contained in the LICENSE file.

"""Elliptic curve classes."""

from math import sqrt

from .alias import Integer, Point
from .curvegroup import _HEXTHRESHOLD, CurveGroup, _mult_aff
from .utils import hex_string, int_from_integer


class CurveSubGroup(CurveGroup):
    "Subgroup of the points of an elliptic curve over Fp generated by G."

    def __init__(self, p: Integer, a: Integer, b: Integer, G: Point) -> None:

        super().__init__(p, a, b)

        # 2. check that xG and yG are integers in the interval [0, p−1]
        # 4. Check that yG^2 = xG^3 + a*xG + b (mod p)
        if len(G) != 2:
            raise ValueError("Generator must a be a sequence[int, int]")
        self.G = (int_from_integer(G[0]), int_from_integer(G[1]))
        if not self.is_on_curve(self.G):
            raise ValueError("Generator is not on the curve")
        self.GJ = self.G[0], self.G[1], 1  # Jacobian coordinates

    def __str__(self) -> str:
        result = super().__str__()
        if self.p > _HEXTHRESHOLD:
            result += f"\n x_G = {hex_string(self.G[0])}"
            result += f"\n y_G = {hex_string(self.G[1])}"
        else:
            result += f"\n x_G = {self.G[0]}"
            result += f"\n y_G = {self.G[1]}"
        return result

    def __repr__(self) -> str:
        result = super().__repr__()[:-1]
        if self.p > _HEXTHRESHOLD:
            result += f", ('{hex_string(self.G[0])}', '{hex_string(self.G[1])}')"
        else:
            result += f", ({self.G[0]}, {self.G[1]})"
        result += ")"
        return result


class Curve(CurveSubGroup):
    "Prime order subgroup of the points of an elliptic curve over Fp."

    def __init__(
        self,
        p: Integer,
        a: Integer,
        b: Integer,
        G: Point,
        n: Integer,
        h: int,
        weakness_check: bool = True,
    ) -> None:

        super().__init__(p, a, b, G)
        n = int_from_integer(n)

        # Security level is expressed in bits, where n-bit security
        # means that the attacker would have to perform 2^n operations
        # to break it. Security bits are half the key size for asymmetric
        # elliptic curve cryptography, i.e. half of the number of bits
        # required to express the group order n or, holding Hasse theorem,
        # to express the field prime p

        self.n = n
        self.nlen = n.bit_length()
        self.nsize = (self.nlen + 7) // 8

        # 5. Check that n is prime.
        if n < 2 or n % 2 == 0 or pow(2, n - 1, n) != 1:
            err_msg = "n is not prime: "
            err_msg += f"{hex_string(n)}" if n > _HEXTHRESHOLD else f"{n}"
            raise ValueError(err_msg)
        delta = int(2 * sqrt(self.p))
        # also check n with Hasse Theorem
        if h < 2:
            if not (self.p + 1 - delta <= n <= self.p + 1 + delta):
                err_msg = "n not in p+1-delta..p+1+delta: "
                err_msg += f"{hex_string(n)}" if n > _HEXTHRESHOLD else f"{n}"
                raise ValueError(err_msg)

        # 7. Check that G ≠ INF, nG = INF
        if self.G[1] == 0:
            m = "INF point cannot be a generator"
            raise ValueError(m)
        Inf = _mult_aff(n, self.G, self)
        if Inf[1] != 0:
            err_msg = "n is not the group order: "
            err_msg += f"{hex_string(n)}" if n > _HEXTHRESHOLD else f"{n}"
            raise ValueError(err_msg)

        # 6. Check cofactor
        exp_h = int(1 / n + delta / n + self.p / n)
        if h != exp_h:
            raise ValueError(f"invalid h: {h}, expected {exp_h}")
        self.h = h

        # 8. Check that n ≠ p
        assert n != p, f"n=p weak curve: {hex_string(n)}"
        #    raise UserWarning("n=p -> weak curve")

        if weakness_check:
            # 8. Check that p^i % n ≠ 1 for all 1≤i<100
            for i in range(1, 100):
                if pow(self.p, i, n) == 1:
                    raise UserWarning("weak curve")

    def __str__(self) -> str:
        result = super().__str__()
        if self.n > _HEXTHRESHOLD:
            result += f"\n n   = {hex_string(self.n)}"
        else:
            result += f"\n n   = {self.n}"
        result += f"\n h = {self.h}"
        return result

    def __repr__(self) -> str:
        result = super().__repr__()[:-1]
        if self.n > _HEXTHRESHOLD:
            result += f", '{hex_string(self.n)}'"
        else:
            result += f", {self.n}"
        result += f", {self.h}"
        result += ")"
        return result
